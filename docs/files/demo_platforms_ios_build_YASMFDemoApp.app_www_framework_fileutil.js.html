<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>demo/platforms/ios/build/YASMFDemoApp.app/www/framework/fileutil.js - YASMF</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../assets/css/logo.png" title="YASMF"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.3.100</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/PKObject.html">PKObject</a></li>
            
                <li><a href="../classes/UI.html">UI</a></li>
            
                <li><a href="../classes/UI.COLOR.html">UI.COLOR</a></li>
            
                <li><a href="../classes/UI.FONT.html">UI.FONT</a></li>
            
                <li><a href="../classes/UI.Label.html">UI.Label</a></li>
            
                <li><a href="../classes/UI.SHADOW.html">UI.SHADOW</a></li>
            
                <li><a href="../classes/UI.View.html">UI.View</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="../modules/PKObject.html">PKObject</a></li>
            
                <li><a href="../modules/UI.html">UI</a></li>
            
                <li><a href="../modules/UI.Label.html">UI.Label</a></li>
            
                <li><a href="../modules/UI.View.html">UI.View</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: demo/platforms/ios/build/YASMFDemoApp.app/www/framework/fileutil.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/******************************************************************************
 *
 * FILEUTIL
 * Author: Kerri Shotts
 *
 * This library includes routines to deal with the FILE API, (which is... a bit
 * painful.) The purpose of the library is to reduce the amount of work necessary
 * to go through obtaining a file system, working with directories and files,
 * etc. That isn&#x27;t to say that we can eliminate callbacks or even callback
 * chaining -- but it is significantly easier without all the intervening cruft,
 * which is essentially (for all intents and purposes) boilerplate.
 *
 * IMPORTANT NOTE:
 *
 * This library provides various conveniences that make referencing persistent
 * and temporary storage a bit easier as well. For example, you can use a
 * path like the following:
 *
 *     doc://photo.jpg   --&gt;   /some/gobbledygook/yourApp/Documents/photo.jpg
 *     tmp://photo.jpg   --&gt;   /some/gobbledygook/yourApp/tmp/photo.jpg
 *
 * Several APIs (such as camera capture) may also refer to paths with
 * &quot;file://localhost&quot; attached. The routines will gracefully remove this so that
 * the reference is a true file.
 *
 * CONVENIENCE:
 *
 * For those who are more comfortable with *nix/BSD commands, nearly each method
 * has a version that correlates to a roughly *nix name. The parameters are the
 * same, however.
 *
 * METHODS
 *   copyFileTo ( source, target, success, failure )         |   cp ()
 *   moveFileTo ( source, target, success, failure )         |   mv ()
 *   removeFile ( theFile, success, failure )                |   rm ()
 *   renameFile ( source, newName, success, failure )        |   -
 *   createFileWriter ( theFile, success, failure )          |   fcreate ()
 *   writeFileData ( writer, theData, success, failure )     |   fwrite ()
 *
 * PLANNED METHODS
 *
 *   getListing ( path, filters, success, failure )          |    ls ()
 *   createDirectory ( path, newDirectory, success, failure )|    mkdir()
 *   removeDirectory ( path, theDirectory, success, failure )|    rmdir()
 *   createFileReader ( theFile, success, failure )          |    fopen()
 *   readFileData ( reader, success, failure )               |    fread()
 *
 *
 ******************************************************************************/

/*jshint
         asi:true,
         bitwise:true,
         browser:true,
         camelcase:true,
         curly:true,
         eqeqeq:false,
         forin:true,
         noarg:true,
         noempty:true,
         plusplus:false,
         smarttabs:true,
         sub:true,
         trailing:false,
         undef:true,
         white:false,
         onevar:false 
 */
/*global LocalFileSystem, PKUTIL, FileEntry, DirectoryEntry*/
PKUTIL.require ( &quot;PKUTIL.FILE&quot;, function () 
{ 
    PKUTIL.export ( &quot;PKFILE&quot; );
});

var PKFILE = PKFILE ||
{
};
// create the namespace
PKFILE.version = { major: 0, minor: 3, rev: 100 };

//
// Properties
//
PKFILE.COMPLETION_SUCCESS = true;
PKFILE.COMPLETION_FAILURE = false;

// set to true to enable console logging
PKFILE.consoleLogging = false;

// these will be set upon first method that needs them
PKFILE.persistentFS = &quot;&quot;;
PKFILE.persistentFSName = &quot;&quot;;

PKFILE.temporaryFS = &quot;&quot;;
PKFILE.temporaryFSName = &quot;&quot;;

//
// Methods
//

/**
 *
 * Determines the persistent and temporary file systems prior
 * to file operations. While it&#x27;s unlikely that these will
 * change during application execution, it certainly doesn&#x27;t
 * hurt to re-read them whenever possible (just in case!).
 *
 * When both are read, the success method is called. If we
 * can&#x27;t obtain one or the other, the failure method is called.
 */
PKFILE._initializeFileSystems = function ( success, failure )
{
  // we need to request two file systems: persistent and temporary.
  window.requestFileSystem(LocalFileSystem.PERSISTENT, 0,
    function (fs)
    {
      PKFILE.persistentFS = fs.root.fullPath;
      PKFILE.persistentFSName = fs.root.name;

      window.requestFileSystem(LocalFileSystem.TEMPORARY, 0,
        function (fs)
        {
          PKFILE.temporaryFS = fs.root.fullPath;
          PKFILE.temporaryFSName = fs.root.name;
          
          if (success)
          {
            success();
          }
        },
        failure
      );

    },
    failure
  );

}

/**
 *
 * Handles substition strings within a file path.
 *
 *  doc:/ translates to the persistent storage. We don&#x27;t use &quot;//&quot; here
 *        since the persistentFS doesn&#x27;t have a trailing &quot;/&quot;, so we leave
 *        that in the original.
 *  tmp:/ translates to the temporary storage.
 *  file://localhost translates to nothing. 
 *
 */
PKFILE._replaceFS = function ( s )
{
  return s.replace ( &quot;doc:/&quot;, PKFILE.persistentFS )
          .replace ( &quot;tmp:/&quot;, PKFILE.temporaryFS )
          .replace ( &quot;file://localhost&quot;, &quot;&quot; );
  
}

/**
 *
 * Copies the file identified by @source to the file identified by @target.
 * If the copy is successful, success() is called. If not, failure() is
 * called.
 *
 * The target will generally be of the form &quot;doc://filename&quot;, but it can
 * be any path and file name that the application has access to.
 *
 * NOTE: Copying will fail if the target exists.
 *
 */
PKFILE.copyFileTo = function ( source, target, success, failure )
{
  PKFILE._initializeFileSystems (
    function()
    {
      var newSource = PKFILE._replaceFS ( source );
      var newTarget = PKFILE._replaceFS ( target );
      var newTargetDir = PKUTIL.FILE.getPathPart (newTarget);
                     
      var sourceFileEntry = new FileEntry ( PKUTIL.FILE.getFilePart ( newSource ),
                                            newSource );

      var targetDirEntry = new DirectoryEntry ( newTargetDir.substr(newTargetDir.lastIndexOf(&#x27;/&#x27;)+1),
                                                newTargetDir);

      sourceFileEntry.copyTo ( targetDirEntry, PKUTIL.FILE.getFilePart ( target ),
                               success, failure );
    },
    failure
  );
}

/**
 *
 * *nix convenience method.
 *
 */
PKFILE.cp = function ( source, target, success, failure )
{
  PKFILE.copyFileTo ( source, target, success, failure );
}

/**
 *
 * Moves the file identified by @source to the file identified by @target.
 * If the move is successful, success() is called. If not, failure() is
 * called.
 *
 * The target will generally be of the form &quot;doc://filename&quot;, but it can
 * be any path and file name that the application has access to.
 *
 * NOTE: The move will overwrite the target if it exists.
 *
 */
PKFILE.moveFileTo = function ( source, target, success, failure )
{
  PKFILE._initializeFileSystems (
    function()
    {
      var newSource = PKFILE._replaceFS ( source );
      var newTarget = PKFILE._replaceFS ( target );
      var newTargetDir = PKUTIL.FILE.getPathPart (newTarget);
                     
      var sourceFileEntry = new FileEntry ( PKUTIL.FILE.getFilePart ( newSource ),
                                            newSource );

      var targetDirEntry = new DirectoryEntry ( newTargetDir.substr(newTargetDir.lastIndexOf(&#x27;/&#x27;)+1),
                                                newTargetDir);

      sourceFileEntry.moveTo ( targetDirEntry, PKUTIL.FILE.getFilePart ( target ),
                               success, failure );
    },
    failure
  );
}

/**
 *
 * Convenience method that allows renaming a file in the same
 * directory as the source. The source&#x27;s path will prepended
 * to the new name.
 *
 * NOTE: The move will overwrite the target if it exists.
 *
 */
PKFILE.renameFile = function ( source, newName, success, failure )
{
  var target = PKUTIL.FILE.getPathPart ( source ) + &quot;/&quot; + newName;
  PKFILE.moveFileTo ( source, target, success, failure );
}

/**
 *
 * *nix convenience method.
 *
 */
PKFILE.mv = function ( source, target, success, failure )
{
  PKFILE.moveFileTo ( source, target, success, failure );
}

/**
 *
 * Removes the file identified by @theFile. The full path must
 * be specified. 
 *
 */
PKFILE.removeFile = function ( theFile, success, failure )
{
  PKFILE._initializeFileSystems (
    function()
    {
      var newSource = PKFILE._replaceFS ( theFile );
      var sourceFileEntry = new FileEntry ( PKUTIL.FILE.getFilePart ( newSource ),
                                            newSource );

      sourceFileEntry.remove ( success, failure );
    },
    failure
  );
}

/**
 *
 * *nix convenience method.
 *
 */
PKFILE.rm = function ( theFile, success, failure )
{
  PKFILE.removeFile ( theFile, success, failure );
}

/**
 *
 * Creates a fileWriter for @theFile. If successful, it will
 * call success() with the created writer. If unsuccessful, it
 * will call failure().
 *
 * Once in success(), writeFileData() may be used to finish
 * the writing of data to the file.
 *
 * Note: if the file exists, it will be overwritten.
 *
 */
PKFILE.createFileWriter = function ( theFile, success, failure )
{
  PKFILE._initializeFileSystems (
    function()
    {
      var newSource = PKFILE._replaceFS ( theFile );
      var sourceFileEntry = new FileEntry ( PKUTIL.FILE.getFilePart ( newSource ),
                                            newSource );

      sourceFileEntry.createWriter ( success, failure );
    },
    failure
  );
}

/**
 *
 * *nix convenience method.
 *
 */
PKFILE.fcreate = function ( theFile, success, failure )
{
  PKFILE.createFileWriter ( theFile, success, failure );
}

/**
 *
 * Writes @theData to the specified writer. When complete,
 * success() will be called. If it fails, failure().
 *
 */
PKFILE.writeFileData = function ( writer, theData, success, failure )
{
  writer.onerror = failure;
  writer.onwriteend = success;
  writer.write ( theData );
}

/**
 *
 * *nix convenience method.
 *
 */
PKFILE.fwrite = function ( writer, theData, success, failure )
{
  PKFILE.writeFileData ( writer, theData, success, failure );
}

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
